// RobotBuilder Version: 6.1
//
// This file was generated by RobotBuilder. It contains sections of
// code that are automatically generated and assigned by robotbuilder.
// These sections will be updated in the future when you export to
// Java from RobotBuilder. Do not put any code or make any change in
// the blocks indicating autogenerated code or it will be lost on an
// update. Deleting the comments indicating the section will prevent
// it from being updated in the future.

// ROBOTBUILDER TYPE: Subsystem.

package frc.robot.subsystems;

import edu.wpi.first.wpilibj2.command.SubsystemBase;

import com.revrobotics.spark.SparkClosedLoopController;

import com.revrobotics.spark.SparkMax;
import com.revrobotics.spark.SparkBase.*;
import com.revrobotics.spark.SparkBase.PersistMode;
import com.revrobotics.spark.SparkLowLevel.MotorType;
import com.revrobotics.spark.config.ClosedLoopConfig.FeedbackSensor;
import com.revrobotics.spark.config.SparkMaxConfig;
import com.revrobotics.RelativeEncoder;
import edu.wpi.first.wpilibj.smartdashboard.SmartDashboard;

import static frc.robot.Constants.AlgaeGrabberConstants.*;

/**
 *
 */
public class AlgaeGrabber extends SubsystemBase {

    private SparkMax ballGrabberMotor; // intake and outtake
    private SparkMax armRotateMotor; // limit max rotation distance
    private SparkClosedLoopController PIDcontroller;

    RelativeEncoder armRotateEnc;

    public AlgaeGrabber() {
        SparkMaxConfig ballGrabberConfig = new SparkMaxConfig();
        // ballGrabberConfig.inverted(true); need to test if this needs inverting
        ballGrabberConfig.inverted(false);
        ballGrabberMotor = new SparkMax(kBallGrabberMotorPort, MotorType.kBrushless);
        ballGrabberMotor.configure(ballGrabberConfig, ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);

        SparkMaxConfig armRotateConfig = new SparkMaxConfig();
        armRotateConfig.inverted(false);
        armRotateConfig.closedLoop
            .p(kP)
            .i(kI)
            .d(kD)
            .outputRange(kMinOutput, kMaxOutput)
            .feedbackSensor(FeedbackSensor.kPrimaryEncoder);
        armRotateConfig.encoder.positionConversionFactor(kArmRotateConverionFactor);
        //shouldnt need velocity conversion because we arent using setpoint for velocity

        armRotateMotor = new SparkMax(kArmRotateMotorPort, MotorType.kBrushless);
        armRotateMotor.configure(armRotateConfig, ResetMode.kResetSafeParameters, PersistMode.kPersistParameters);

        armRotateEnc = armRotateMotor.getEncoder();
        PIDcontroller = armRotateMotor.getClosedLoopController();
    }

    @Override
    public void periodic() {
        SmartDashboard.putNumber("Arm Position", armRotateEnc.getPosition());
    }

    @Override
    public void simulationPeriodic() {
        // This method will be called once per scheduler run when in simulation

    }

    // Put methods for controlling this subsystem
    // here. Call these from Commands.
    public void resetEncoders() {
        armRotateEnc.setPosition(0);
    }

    public void setBallGrabberMotor(double speed) {
        //ballGrabberMotor.set(speed);
    }

    public void goToSetpoint(double setpoint) {
        PIDcontroller.setReference(setpoint, ControlType.kPosition);
    }

    public void setArmRotateMotor(double speed) {
        if(armRotateEnc.getPosition() >= kMaxPosition || armRotateEnc.getPosition() <= kMinPosition) {
            armRotateMotor.set(0);
        } else {
            if(armRotateEnc.getPosition() >= kMaxPosition) {
                // algae arm is too far up
                if(speed < 0) {
                    armRotateMotor.set(speed);
                }
            } else {
                // algae arm is too far down
                if(speed > 0) {
                    armRotateMotor.set(speed);
                }
            }
        }
    }
}

